// UTILS
static int ProgramCtxCtor (ProgramCtx* program_ctx, const Program *const program);
static int ProgramCtxDtor (ProgramCtx* program_ctx);

static Token* VarInitialization (ProgramCtx* program_ctx);
static int   FuncInitialization (ProgramCtx* program_ctx);


static FuncLabel* MakeFuncLabel (ProgramCtx* program_ctx, Token** func_head);
// static VarLabel*  MakeVarLabel  (ProgramCtx* program_ctx);

static int DefineName (ProgramCtx* program_ctx);

///////////////////////////////////////////////////////////////////////////
static int ProgramCtxCtor (ProgramCtx* program_ctx, const Program *const program)
    {
    assertlog(program_ctx, EFAULT, return BAD_ARGUMENT);
    assertlog(program,     EFAULT, return BAD_ARGUMENT);

    SuperStack* var_tabels_stk = (SuperStack*) CALLOC (1, sizeof(var_tabels_stk[0]));
    if (!var_tabels_stk)
        return FAILURE;

    StackCtor(var_tabels_stk, START_NUMBER_OF_VAR_TABELS_STK);

    FuncTabel* global_func = NewFuncTabel();
    if (!global_func)
        {
        StackDtor(var_tabels_stk);
        free(var_tabels_stk);

        return FAILURE;
        }

    VarTabel* global_var_tabel = NewVarTabel();
    if (!global_var_tabel)
        {
        StackDtor(var_tabels_stk);
        free(var_tabels_stk);
        
        CloseFuncTabel(global_func);

        return FAILURE;
        }

    StackPush(var_tabels_stk, global_var_tabel);

    program_ctx->position = 0;
    program_ctx->current_func_label = 0;
    program_ctx->global_func = global_func;
    program_ctx->global_vars = global_var_tabel;
    program_ctx->var_tabels_stk = var_tabels_stk;

    return SUCCESS;
    }
    
static int ProgramCtxDtor(ProgramCtx* program_ctx)
    {
    assertlog(program_ctx, EFAULT, return BAD_ARGUMENT);

    StackDtor(program_ctx->var_tabels_stk);
    free(program_ctx->var_tabels_stk);

    CloseVarTabel (program_ctx->global_vars);
    CloseFuncTabel(program_ctx->global_func);

    return SUCCESS;
    }

static int DefineName(ProgramCtx* program_ctx)
    {
    assertlog(program_ctx, EFAULT, return NOT_DECLARED);

    if (TYPE(token) != NAME)
        {
        report_syntax_error("Not a name\n");
        return NOT_DECLARED;
        }

    // what if function and variable has same name ? 
    if (IsFuncLabel (NAME_ID(token), FUNC_TABEL(program_ctx)))
        {
        TYPE(token) = FUNCTION;
        return FUNCTION;
        }

    if (GetVarLabel (NAME_ID(token), VAR_TABELS_STK(program_ctx)))
        {
        TYPE(token) = VARIABLE;
        return VARIABLE;
        }

    report_syntax_error("'%s' wasn't decalred\n", STRING_ARR(program_ctx)[NAME_ID(token)]);
    
    return NOT_DECLARED;
    } 

static FuncLabel* MakeFuncLabel(ProgramCtx* program_ctx, Token** func_head)
    {
    assertlog(program_ctx, EFAULT, return LNULL);
    assertlog(func_head,   EFAULT, return LNULL);

    FuncLabel* label = (FuncLabel*) CALLOC (1, sizeof(label[0]));
    if (!label) return LNULL;

    if (TYPE(token) != FUNCTION_RET_TYPE)
        {
        report_syntax_error("No return type in function\n");
        return LNULL;
        }
    
    Token* ret_type = token;
    POSITION(program_ctx)++;

    label->ret_type = RET_TYPE(ret_type);

    if (TYPE(token) != NAME)
        {
        report_syntax_error("No function name\n");
        return LNULL;
        }

    Token* name = token;
    POSITION(program_ctx)++;

    label->name = NAME_ID(name);
            
    // argument
    if(TYPE(token) != EXPRESSION_OPENING_BRACKET)
        {
        report_syntax_error("Missing '(' in function prototype\n");
        return LNULL;
        }
    POSITION(program_ctx)++;
    // TO_DO

    if(TYPE(token) != EXPRESSION_CLOSING_BRACKET)
       {
       report_syntax_error("Missing ')' in function \n");
       return LNULL;
       }
    POSITION(program_ctx)++;

    // set func_head
    RIGHT(name) = ret_type;

    *func_head = name;

    return label;
    } 

/*
static VarLabel* MakeVarLabel(ProgramCtx* program_ctx)
    {
    $log(1)
    assertlog(program_ctx, EFAULT, return LNULL);

    VarLabel* label = (VarLabel*) CALLOC (1, sizeof(label[0]));
    if (!label) return LNULL;

    if (TYPE(token) != NAME)
        {
        report_syntax_error("Ebat, not a name for variable initialization\n", STRING_ARR(program_ctx)[NAME_ID(token)]);
        return LNULL;
        }

    label->name_id =  NAME_ID(token);

    return label;
    }
*/

/*
static Token* FuncLabelToTokens (FuncLabel* label)
    {
    assertlog(label, EFAULT, return LNULL);

    Token* name = NewToken (NAME, {.t_name_id = label->name});
    
    RIGHT(name) = NewToken (FUNCTION_RET_TYPE, {.t_function_ret_type = label->ret_type});

    / NOT NOW
    Token* temp = NewToken(
    for(int i = 0; i < label->number_of_arguments; i++)
        {

    /

    return name;
    }
*/


